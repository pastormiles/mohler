"""
AlbertMohler - YouTube Semantic Search API
============================================================

Flask server for semantic search across Albert Mohler's YouTube transcripts.

Endpoints:
  GET  /                    - Search interface
  GET  /api/v1/health       - Health check
  POST /api/v1/search       - Search transcripts
  POST /api/v1/summarize    - AI summary
  GET  /api/v1/stats        - Index statistics
  GET  /admin               - Admin dashboard

Generated by 07_local_POC_v1.py
"""

import os
import sys
import json
import sqlite3
import hashlib
import time
import threading
from pathlib import Path
from datetime import datetime, timedelta
from collections import OrderedDict
from functools import wraps

from flask import Flask, request, jsonify, send_from_directory, Response, Blueprint
from flask_cors import CORS
from dotenv import load_dotenv

# =============================================================================
# PATH SETUP - Import from parent config.py
# =============================================================================
SERVER_DIR = Path(__file__).parent
PROJECT_ROOT = SERVER_DIR.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Load environment variables from project root
load_dotenv(PROJECT_ROOT / ".env")

# Import configuration
from config import (
    CHANNEL_HANDLE, CHANNEL_DISPLAY_NAME,
    PINECONE_INDEX, PINECONE_NAMESPACE,
    SERVER_PORT, ALLOWED_ORIGINS,
    API_KEY_POC, API_KEY_WORDPRESS,
    ADMIN_USERNAME, ADMIN_PASSWORD,
    EMBEDDING_MODEL,
    OPENAI_API_KEY, PINECONE_API_KEY,
)

# =============================================================================
# FLASK APP SETUP
# =============================================================================
app = Flask(__name__, static_folder='static')

# Configure CORS
cors_origins = ALLOWED_ORIGINS + ["http://localhost:5005", "http://127.0.0.1:5005"]
CORS(app, origins=cors_origins if cors_origins else "*")

# Create API Blueprint
api_v1 = Blueprint('api_v1', __name__, url_prefix='/api/v1')

# =============================================================================
# EXTERNAL CLIENTS (lazy initialization)
# =============================================================================
_pinecone_index = None
_openai_client = None


def get_pinecone_index():
    """Lazy initialization of Pinecone client."""
    global _pinecone_index
    if _pinecone_index is None:
        try:
            from pinecone import Pinecone
            pc = Pinecone(api_key=PINECONE_API_KEY)
            _pinecone_index = pc.Index(PINECONE_INDEX)
            print(f"‚úì Connected to Pinecone index: {PINECONE_INDEX}")
        except Exception as e:
            print(f"‚úó Pinecone connection failed: {e}")
            raise
    return _pinecone_index


def get_openai_client():
    """Lazy initialization of OpenAI client."""
    global _openai_client
    if _openai_client is None:
        try:
            from openai import OpenAI
            _openai_client = OpenAI(api_key=OPENAI_API_KEY)
            print(f"‚úì OpenAI client initialized")
        except Exception as e:
            print(f"‚úó OpenAI initialization failed: {e}")
            raise
    return _openai_client


# =============================================================================
# SIMPLE CACHE
# =============================================================================
class SimpleCache:
    """Thread-safe in-memory cache with TTL."""
    
    def __init__(self, max_entries=1000, ttl_seconds=3600):
        self.max_entries = max_entries
        self.ttl_seconds = ttl_seconds
        self.cache = OrderedDict()
        self.lock = threading.RLock()
        self.hits = 0
        self.misses = 0
    
    def _make_key(self, query: str) -> str:
        return hashlib.sha256(query.lower().strip().encode()).hexdigest()[:16]
    
    def get(self, query: str):
        with self.lock:
            key = self._make_key(query)
            if key in self.cache:
                entry = self.cache[key]
                if time.time() - entry['timestamp'] <= self.ttl_seconds:
                    self.cache.move_to_end(key)
                    self.hits += 1
                    return entry['data']
                else:
                    del self.cache[key]
            self.misses += 1
            return None
    
    def set(self, query: str, data):
        with self.lock:
            key = self._make_key(query)
            self.cache[key] = {'data': data, 'timestamp': time.time()}
            self.cache.move_to_end(key)
            while len(self.cache) > self.max_entries:
                self.cache.popitem(last=False)
    
    def stats(self):
        total = self.hits + self.misses
        hit_rate = (self.hits / total * 100) if total > 0 else 0
        return {
            'entries': len(self.cache),
            'hits': self.hits,
            'misses': self.misses,
            'hit_rate': f"{hit_rate:.1f}%"
        }
    
    def clear(self):
        with self.lock:
            self.cache.clear()
            self.hits = 0
            self.misses = 0


# Initialize caches
search_cache = SimpleCache(max_entries=1000, ttl_seconds=3600)
summary_cache = SimpleCache(max_entries=500, ttl_seconds=3600)


# =============================================================================
# API KEY AUTHENTICATION
# =============================================================================
API_KEYS = {}
if API_KEY_POC:
    API_KEYS[API_KEY_POC] = 'poc'
if API_KEY_WORDPRESS:
    API_KEYS[API_KEY_WORDPRESS] = 'wordpress'


def require_api_key(f):
    """Decorator requiring valid API key in X-API-Key header."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        
        if not api_key:
            return jsonify({
                'error': 'API key required',
                'message': 'Include X-API-Key header with your request'
            }), 401
        
        if api_key not in API_KEYS:
            return jsonify({
                'error': 'Invalid API key',
                'message': 'The provided API key is not valid'
            }), 401
        
        request.client_name = API_KEYS[api_key]
        return f(*args, **kwargs)
    
    return decorated_function


def optional_api_key(f):
    """Decorator that checks API key but doesn't require it."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        
        if api_key and api_key in API_KEYS:
            request.client_name = API_KEYS[api_key]
        else:
            request.client_name = 'anonymous'
        
        return f(*args, **kwargs)
    
    return decorated_function


# =============================================================================
# ADMIN AUTHENTICATION
# =============================================================================
def check_admin_auth(username, password):
    """Verify admin credentials."""
    return username == ADMIN_USERNAME and password == ADMIN_PASSWORD


def require_admin_auth(f):
    """Decorator for HTTP Basic Auth on admin routes."""
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_admin_auth(auth.username, auth.password):
            return Response(
                'Authentication required for admin access.',
                401,
                {'WWW-Authenticate': 'Basic realm="Albert Mohler Admin"'}
            )
        return f(*args, **kwargs)
    return decorated


# =============================================================================
# RATE LIMITING
# =============================================================================
rate_limit_data = {}


def check_rate_limit(client_key, limit_per_minute, limit_per_hour):
    """Check if client has exceeded rate limits."""
    now = datetime.now()
    minute_ago = now - timedelta(minutes=1)
    hour_ago = now - timedelta(hours=1)
    
    if client_key not in rate_limit_data:
        rate_limit_data[client_key] = []
    
    # Clean old entries
    rate_limit_data[client_key] = [
        t for t in rate_limit_data[client_key] 
        if t > hour_ago
    ]
    
    requests_last_minute = sum(1 for t in rate_limit_data[client_key] if t > minute_ago)
    requests_last_hour = len(rate_limit_data[client_key])
    
    if requests_last_minute >= limit_per_minute:
        return False, 60
    
    if requests_last_hour >= limit_per_hour:
        return False, 3600
    
    rate_limit_data[client_key].append(now)
    return True, 0


def rate_limit(per_minute=30, per_hour=200):
    """Decorator to apply rate limiting."""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            api_key = request.headers.get('X-API-Key', request.remote_addr)
            
            allowed, retry_after = check_rate_limit(
                f"{api_key}:{f.__name__}", 
                per_minute, 
                per_hour
            )
            
            if not allowed:
                return jsonify({
                    'error': 'Rate limit exceeded',
                    'retry_after': retry_after,
                    'message': f'Please wait {retry_after} seconds before trying again'
                }), 429
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


# =============================================================================
# ANALYTICS
# =============================================================================
ANALYTICS_DB = SERVER_DIR / "data" / "analytics.db"


def init_analytics_db():
    """Initialize SQLite analytics database."""
    ANALYTICS_DB.parent.mkdir(parents=True, exist_ok=True)
    
    conn = sqlite3.connect(str(ANALYTICS_DB))
    c = conn.cursor()
    
    c.execute('''
        CREATE TABLE IF NOT EXISTS searches (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            query TEXT NOT NULL,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            client TEXT,
            results_count INTEGER
        )
    ''')
    
    conn.commit()
    conn.close()


def record_search(query, client, results_count):
    """Record a search in analytics database."""
    try:
        conn = sqlite3.connect(str(ANALYTICS_DB))
        c = conn.cursor()
        c.execute(
            'INSERT INTO searches (query, client, results_count) VALUES (?, ?, ?)',
            (query, client, results_count)
        )
        conn.commit()
        conn.close()
    except Exception as e:
        print(f"Analytics error: {e}")


def get_analytics(days=7):
    """Get analytics summary."""
    try:
        conn = sqlite3.connect(str(ANALYTICS_DB))
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        
        cutoff = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d %H:%M:%S')
        
        c.execute('SELECT COUNT(*) as count FROM searches WHERE timestamp > ?', (cutoff,))
        total_searches = c.fetchone()['count']
        
        c.execute('SELECT COUNT(DISTINCT query) as count FROM searches WHERE timestamp > ?', (cutoff,))
        unique_queries = c.fetchone()['count']
        
        c.execute('''
            SELECT query, COUNT(*) as count 
            FROM searches WHERE timestamp > ?
            GROUP BY LOWER(query) ORDER BY count DESC LIMIT 20
        ''', (cutoff,))
        top_queries = [{'query': row['query'], 'count': row['count']} for row in c.fetchall()]
        
        c.execute('''
            SELECT client, COUNT(*) as count 
            FROM searches WHERE timestamp > ?
            GROUP BY client
        ''', (cutoff,))
        by_client = {row['client']: row['count'] for row in c.fetchall()}
        
        c.execute('''
            SELECT DATE(timestamp) as date, COUNT(*) as count 
            FROM searches WHERE timestamp > ?
            GROUP BY DATE(timestamp) ORDER BY date DESC
        ''', (cutoff,))
        by_day = [{'date': row['date'], 'count': row['count']} for row in c.fetchall()]
        
        conn.close()
        
        return {
            'period': f'{days} days',
            'total_searches': total_searches,
            'unique_queries': unique_queries,
            'top_queries': top_queries,
            'searches_by_client': by_client,
            'searches_by_day': by_day
        }
    except Exception as e:
        return {'error': str(e)}


def get_recent_searches(limit=20):
    """Get recent searches."""
    try:
        conn = sqlite3.connect(str(ANALYTICS_DB))
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        
        c.execute('''
            SELECT query, timestamp, client, results_count
            FROM searches ORDER BY timestamp DESC LIMIT ?
        ''', (limit,))
        
        searches = [{
            'query': row['query'],
            'timestamp': row['timestamp'],
            'client': row['client'],
            'results_count': row['results_count']
        } for row in c.fetchall()]
        
        conn.close()
        return searches
    except Exception as e:
        return []


# =============================================================================
# API ROUTES
# =============================================================================

@api_v1.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    try:
        # Test Pinecone connection
        index = get_pinecone_index()
        stats = index.describe_index_stats()
        pinecone_status = 'connected'
        vector_count = stats.get('namespaces', {}).get(PINECONE_NAMESPACE, {}).get('vector_count', 0)
    except Exception as e:
        pinecone_status = f'error: {str(e)}'
        vector_count = 0
    
    return jsonify({
        'status': 'healthy',
        'version': 'youtube-search-v1',
        'channel': CHANNEL_DISPLAY_NAME,
        'pinecone_index': PINECONE_INDEX,
        'pinecone_namespace': PINECONE_NAMESPACE,
        'pinecone_status': pinecone_status,
        'vector_count': vector_count,
        'cache': search_cache.stats()
    })


@api_v1.route('/search', methods=['POST'])
@optional_api_key
@rate_limit(per_minute=30, per_hour=200)
def search():
    """Search YouTube transcripts."""
    try:
        data = request.get_json()
        query = data.get('query', '')
        top_k = min(data.get('top_k', 15), 50)
        
        if not query:
            return jsonify({'error': 'Query is required'}), 400
        
        # Check cache
        cached = search_cache.get(query)
        if cached:
            return jsonify({
                'query': query,
                'results': cached,
                'count': len(cached),
                'cached': True
            })
        
        # Generate embedding
        client = get_openai_client()
        response = client.embeddings.create(
            model=EMBEDDING_MODEL,
            input=query
        )
        query_embedding = response.data[0].embedding
        
        # Search Pinecone
        index = get_pinecone_index()
        results = index.query(
            vector=query_embedding,
            top_k=top_k,
            include_metadata=True,
            namespace=PINECONE_NAMESPACE
        )
        
        # Format results
        formatted_results = []
        seen_videos = set()
        
        for match in results['matches']:
            metadata = match['metadata']
            video_id = metadata.get('video_id', '')
            
            formatted_results.append({
                'score': match['score'],
                'chunk_id': match['id'],
                'video_id': video_id,
                'video_title': metadata.get('video_title', ''),
                'text': metadata.get('text', ''),
                'start_time': metadata.get('start_time', 0),
                'end_time': metadata.get('end_time', 0),
                'start_timestamp': metadata.get('start_timestamp', '0:00'),
                'end_timestamp': metadata.get('end_timestamp', '0:00'),
                'thumbnail_url': metadata.get('thumbnail_url', ''),
                'youtube_url': metadata.get('youtube_url', ''),
                'is_new_video': video_id not in seen_videos
            })
            seen_videos.add(video_id)
        
        # Cache and record
        search_cache.set(query, formatted_results)
        record_search(query, getattr(request, 'client_name', 'anonymous'), len(formatted_results))
        
        return jsonify({
            'query': query,
            'results': formatted_results,
            'count': len(formatted_results),
            'unique_videos': len(seen_videos),
            'cached': False
        })
        
    except Exception as e:
        print(f"Search error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@api_v1.route('/summarize', methods=['POST'])
@optional_api_key
@rate_limit(per_minute=10, per_hour=50)
def summarize_results():
    """Generate AI summary of search results."""
    try:
        data = request.get_json()
        query = data.get('query', '')
        results = data.get('results', [])
        
        if not query:
            return jsonify({'error': 'Query is required'}), 400
        
        if not results:
            return jsonify({'error': 'No results to summarize'}), 400
        
        # Check cache
        cache_key = f"{query}:{len(results)}"
        cached = summary_cache.get(cache_key)
        if cached:
            cached['cached'] = True
            return jsonify(cached)
        
        # Use top 5 results
        top_results = results[:5]
        
        context_parts = []
        for i, result in enumerate(top_results, 1):
            context_parts.append(
                f"[Video {i}: {result.get('video_title', 'Unknown')} at {result.get('start_timestamp', '0:00')}]\n"
                f"Transcript: {result.get('text', '')[:600]}"
            )
        
        context = "\n\n".join(context_parts)
        
        # Generate summary
        client = get_openai_client()
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are a helpful assistant summarizing content from "
                        "Albert Mohler's YouTube videos. Synthesize the provided "
                        "transcript excerpts into a clear, informative answer of 150-200 words. "
                        "Mention which videos discuss the topic. Be accurate and faithful to "
                        "what was actually said."
                    )
                },
                {
                    "role": "user",
                    "content": f"Question: {query}\n\nVideo transcript excerpts:\n\n{context}"
                }
            ],
            max_tokens=400,
            temperature=0.3
        )
        
        summary = response.choices[0].message.content
        
        # Get all sources with details
        sources = []
        seen_videos = set()
        for r in top_results:
            video_id = r.get('video_id', '')
            if video_id and video_id not in seen_videos:
                sources.append({
                    'title': r.get('video_title', ''),
                    'timestamp': r.get('start_timestamp', '0:00'),
                    'url': r.get('youtube_url', '')
                })
                seen_videos.add(video_id)

        result_data = {
            'query': query,
            'summary': summary,
            'sources': sources,
            'sources_count': len(top_results),
            'cached': False
        }
        
        summary_cache.set(cache_key, result_data)
        
        return jsonify(result_data)
        
    except Exception as e:
        print(f"Summarize error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@api_v1.route('/stats', methods=['GET'])
@optional_api_key
def get_stats():
    """Get index statistics."""
    try:
        index = get_pinecone_index()
        stats = index.describe_index_stats()
        namespaces = stats.get('namespaces', {})
        youtube_stats = namespaces.get(PINECONE_NAMESPACE, {})
        
        return jsonify({
            'namespace': PINECONE_NAMESPACE,
            'vector_count': youtube_stats.get('vector_count', 0),
            'total_index_vectors': stats.get('total_vector_count', 0)
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@api_v1.route('/admin/dashboard-data', methods=['GET'])
@require_admin_auth
def admin_dashboard_data():
    """Get dashboard data."""
    try:
        # Pinecone stats
        try:
            index = get_pinecone_index()
            stats = index.describe_index_stats()
            pinecone_status = 'connected'
            total_vectors = stats.get('namespaces', {}).get(PINECONE_NAMESPACE, {}).get('vector_count', 0)
        except Exception as e:
            pinecone_status = f'error: {str(e)}'
            total_vectors = 0
        
        return jsonify({
            'system': {
                'api_version': 'v1',
                'channel': CHANNEL_DISPLAY_NAME,
                'pinecone_status': pinecone_status,
                'total_vectors': total_vectors,
            },
            'analytics_1d': get_analytics(1),
            'analytics_7d': get_analytics(7),
            'analytics_30d': get_analytics(30),
            'recent_searches': get_recent_searches(20),
            'cache': {
                'search': search_cache.stats(),
                'summary': summary_cache.stats()
            },
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500


# Register blueprint
app.register_blueprint(api_v1)


# =============================================================================
# ADMIN DASHBOARD
# =============================================================================
ADMIN_HTML = '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albert Mohler Search - Admin</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f7fa; color: #333; }
        .header { background: linear-gradient(135deg, #1e3a5f 0%, #2d5a87 100%); color: white; padding: 20px 30px; display: flex; justify-content: space-between; align-items: center; }
        .header h1 { font-size: 1.5rem; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .card { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
        .card-title { font-size: 0.9rem; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 15px; }
        .stat-value { font-size: 2.5rem; font-weight: 700; color: #1e3a5f; }
        .stat-label { color: #888; font-size: 0.85rem; }
        .status-healthy { color: #155724; }
        .status-error { color: #721c24; }
        table { width: 100%; border-collapse: collapse; }
        th, td { text-align: left; padding: 10px; border-bottom: 1px solid #eee; }
        .refresh-btn { background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; }
        .refresh-btn:hover { background: rgba(255,255,255,0.3); }
        .back-link { color: rgba(255,255,255,0.8); text-decoration: none; }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>Albert Mohler Search Dashboard</h1>
        </div>
        <div>
            <a href="/" class="back-link">‚Üê Back to Search</a>
            <button class="refresh-btn" onclick="loadDashboard()">‚Üª Refresh</button>
        </div>
    </div>
    <div class="container">
        <div id="dashboard">Loading...</div>
    </div>
    <script>
        async function loadDashboard() {
            try {
                const res = await fetch('/api/v1/admin/dashboard-data');
                const data = await res.json();
                
                const sys = data.system;
                const a7d = data.analytics_7d;
                const recent = data.recent_searches || [];
                
                document.getElementById('dashboard').innerHTML = `
                    <div class="grid">
                        <div class="card">
                            <div class="card-title">System Status</div>
                            <p class="${sys.pinecone_status === 'connected' ? 'status-healthy' : 'status-error'}">
                                Pinecone: ${sys.pinecone_status}
                            </p>
                            <p>Vectors: ${sys.total_vectors?.toLocaleString() || 0}</p>
                        </div>
                        <div class="card">
                            <div class="card-title">Last 7 Days</div>
                            <div class="stat-value">${a7d.total_searches || 0}</div>
                            <div class="stat-label">searches</div>
                        </div>
                        <div class="card">
                            <div class="card-title">Cache Performance</div>
                            <p>Search: ${data.cache?.search?.hit_rate || '0%'} hit rate</p>
                            <p>Summary: ${data.cache?.summary?.hit_rate || '0%'} hit rate</p>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title">Recent Searches</div>
                        <table>
                            <thead><tr><th>Time</th><th>Query</th><th>Client</th><th>Results</th></tr></thead>
                            <tbody>
                                ${recent.slice(0, 15).map(s => `
                                    <tr>
                                        <td>${new Date(s.timestamp).toLocaleString()}</td>
                                        <td>${s.query}</td>
                                        <td>${s.client}</td>
                                        <td>${s.results_count}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            } catch (e) {
                document.getElementById('dashboard').innerHTML = `<div class="card">Error: ${e.message}</div>`;
            }
        }
        loadDashboard();
        setInterval(loadDashboard, 60000);
    </script>
</body>
</html>'''


@app.route('/admin')
@require_admin_auth
def admin_dashboard():
    """Serve admin dashboard."""
    return ADMIN_HTML


# =============================================================================
# STATIC ROUTES
# =============================================================================

@app.route('/')
def home():
    """Serve search interface."""
    return send_from_directory('static', 'index.html')


# Legacy routes for backward compatibility
@app.route('/search', methods=['POST'])
@optional_api_key
@rate_limit(per_minute=30, per_hour=200)
def legacy_search():
    return search()


@app.route('/summarize', methods=['POST'])
@optional_api_key
@rate_limit(per_minute=10, per_hour=50)
def legacy_summarize():
    return summarize_results()


@app.route('/health', methods=['GET'])
def legacy_health():
    return health_check()


@app.route('/stats', methods=['GET'])
def legacy_stats():
    return get_stats()


# =============================================================================
# STARTUP
# =============================================================================

if __name__ == '__main__':
    # Initialize analytics database
    init_analytics_db()
    
    print()
    print("=" * 60)
    print(f"üé¨ {CHANNEL_DISPLAY_NAME} YouTube Search API")
    print("=" * 60)
    print()
    print(f"Channel:   {CHANNEL_DISPLAY_NAME} ({CHANNEL_HANDLE})")
    print(f"Pinecone:  {PINECONE_INDEX} / {PINECONE_NAMESPACE}")
    print()
    print("Endpoints:")
    print(f"  GET  http://localhost:{SERVER_PORT}/           - Search UI")
    print(f"  GET  http://localhost:{SERVER_PORT}/admin      - Admin Dashboard")
    print(f"  POST http://localhost:{SERVER_PORT}/api/v1/search")
    print(f"  POST http://localhost:{SERVER_PORT}/api/v1/summarize")
    print(f"  GET  http://localhost:{SERVER_PORT}/api/v1/health")
    print(f"  GET  http://localhost:{SERVER_PORT}/api/v1/stats")
    print()
    print("=" * 60)
    print()
    
    app.run(host='0.0.0.0', port=SERVER_PORT, debug=True)
